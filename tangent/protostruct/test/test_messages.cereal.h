#pragma once
// Generated by protostruct. DO NOT EDIT BY HAND!

#include "tangent/protostruct/cereal_utils.h"
#include "tangent/protostruct/test/test_messages.h"

template <class Archive>
int32_t save_minimal(const Archive& ar, const MyEnumA& value) {
  return static_cast<int32_t>(value);
}

template <class Archive>
void load_minimal(const Archive& ar, MyEnumA& out_value,
                  const int32_t& in_value) {
  switch (in_value) {
    case MyEnumA_VALUE1:
      out_value = MyEnumA_VALUE1;
      return;
    case MyEnumA_VALUE2:
      out_value = MyEnumA_VALUE2;
      return;
    case MyEnumA_VALUE3:
      out_value = MyEnumA_VALUE3;
      return;
  }
}

template <class Archive>
void serialize(Archive& archive, MyMessageA& cobj) {
  archive(cereal::make_nvp("fieldA", cobj.fieldA));
  archive(cereal::make_nvp("fieldB", cobj.fieldB));
  archive(cereal::make_nvp("fieldC", cobj.fieldC));
  archive(cereal::make_nvp("fieldD", cobj.fieldD));
}

template <class Archive>
void serialize(Archive& archive, MyMessageB& cobj) {
  archive(cereal::make_nvp("fieldA", cobj.fieldA));
}

template <class Archive>
void serialize(Archive& archive, MyMessageC& cobj) {
  archive(cereal::make_nvp(
      "fieldA", protostruct::cereal_array(cobj.fieldA, cobj.fieldACount)));
  archive(cereal::make_nvp(
      "fieldB", protostruct::cereal_array(cobj.fieldB, cobj.fieldBCount)));
  archive(cereal::make_nvp(
      "fieldC", protostruct::cereal_array(cobj.fieldC, cobj.fieldCCount)));
}
